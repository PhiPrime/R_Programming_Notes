---
title: "R Programming"
author: "Coursera Course by John Hopkins University"
date: "INSTRUCTORS: Dr. Jeff Leek, Dr. Roger D. Peng, Dr. Brian Caffo"
fontsize: 11pt
output: 
  pdf_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
***
# Overview of R, R data types and objects, reading and writing data

## Installing R & RStudio
* This was covered in the [previous course](https://docs.google.com/document/d/12Co5sjoHIaxAcpTWHRSIs8APAqIlaoOVMFRdGCsMKU0/edit?usp=sharing).

## RMarkdown reference site  
* [I found a site that expands on some features of R-Markdown and have been referencing it pretty regularly](https://bookdown.org/yihui/rmarkdown/pdf-document.html)

## Swirl
* swirl teaches you R programming and data science interactively, at your own pace, and right in the R console.  
* Start swirl  
  + install the package "swirl" if you haven't yet  
  + Everytime you want to run swirl execute:  
    - library("swirl")  
    - swirl()  
  + You'll then be prompted to install a course  
  + [Help page for swirl](https://swirlstats.com/help.html)  

## History of S and R programming
* What is S?  
  + R is a dialect of S  
  + S was developed by John Chambers and others at Bell Labs  
  + Initiated in 1976 as an internal statistical analysis environment, implemented as Fortran libraries
    - Early versions did not contain functions for statistical modeling  
  + Version 3 was released in 1988, which was rewritten in C and began to resemble the system that we have today.  
  + Version 4 was released in 1998 and is the version we use today.  
    - This version is documented in *Programming with Data* by John Chambers (the green book) 
  + Insightful sells its implementation of the S language under the name *S-PLUS*, which includes a number of fancy features, mostly GUIs. 
  + S won the Association for Computing Machinery's Software System Award in '98  
  + (More about S)[https://web.archive.org/web/20181014111802/ect.bell-labs.com/sl/S/]  

* What is R?  
  + R was developed by Ross Ihaka and Robert Gentleman, they documented thier experience in a (1996 JCGS paper)[https://amstat.tandfonline.com/doi/abs/10.1080/10618600.1996.10474713].  
  + In 1995, R become free software after Martin Machler convinced Ross & Robert to use the GNU (General Public License)  
  + Versions  
    - R version 1.0.0 was released in 2000  
    - R version 3.0.2 is released in Dec. 2013  
  + Syntax is similar to S, making it easy for S-PLUS users to switch over  
  + Runs on almost any standard computing platform/OS (even on the PS3)  
  + Frequent releases; active development and communities  
  + Funtionality is divided into modular packages as to keep it "lean"  
  + It's free!  
  + What is free about Free Software?  
    - Freedom 0: freedom to run the program, for any purpose  
    - Freedom 1: freedom to study how the program works, and adapt it to one's needs. Which implies access to the source code
    - Freedom 2: freedom to redistribute copies
    - Freedom 3: freedom to improve the program, and release your improvements to the public, or to sell them.
    - These are outlined by the (Free Software Foundation)[https://www.fsf.org/]  

* Drawbacks of R  
  + Essentially based on 40 year old technology,the original S language
  + Little build support for dynamic or 3D graphics. Although there are packages for such
  + Functionality is based on consumer demand and use contributions, if a feature is not present you'll have to build it.  
  + Objects that are manipulated in R have to be stored in the physical memory of the computer, as such if an object is bigger than the memory you'll be unable to load it into memory  
  + Not ideal for all possible situations, such as calling to order pizza (but this is a drawback of all software packages)  

*Design of the R System  
  + "base" R system that can be downloaded from (CRAN)[http://cran.r-project.org] (krey-an) which...  
    - contains the packages: **utils, stats, datasets, graphics, grDevices, grid, methods, tools, parallel, compiler, splines, tcltk, stats4**.  
    - and "Recommends" the packages: **boot, class, cluster, codetools, foreign, KernSmooth, lattice, mgcv, nlme, rpart, survival, MASS, spatial, nnet, Matrix**.  
  + Packages are available all around the web, but packages on CRAN have to meet a certain level of quality.  

* Some Useful Books on S/R  
  + Chambers (2008). *Software for Data Analysis*, Springer.    
  + Chambers (1998). *Programming with Data*, Springer.  
  + Venables & Ripley (2002). *Modern Applied Statistics with S*, Springer.  
  + Venables & Ripley (2000). *S Programming*, Springer.   
  + Pinheiro & Bates (2000). *Mixed-Effects Models in S and S-Plus*, Springer.  
  + Murrell (2005). *R Graphics*, Chapman & Hall/CRC Press.  
  + (Additional Books)[http://www.r-project.org/doc/bib/R-books.html]  

## Review of getting help
* [Covered in previous course](https://docs.google.com/document/d/12Co5sjoHIaxAcpTWHRSIs8APAqIlaoOVMFRdGCsMKU0/edit?usp=sharing)  

## Input and Evaluation: Vocabulary/Syntax

* **Expressions -** The code that is typed into the R prompt.  
* **Assignment Operator -** assigns a value to a symbol, Ex:  
```x <- 1```  
* *Output a variable*:  
```{r echo= TRUE}
x <- 36
print(x) ##explicit printing
## or one can just type the variable 
x ##auto-printing
```

* *Comment:* Use a Hash(#) symbol to make a comment to the right of #  
* *[1]* is indicating the following variable is the first element of the vector

```{r echo= TRUE}
x <- 1:30 ##Loads x with the numbers 1 to 30
print(x)
## here, [26] is telling you the next number is the 26th element of the vector
```

* `Inf` - represents infinity and can be used in ordinary calculations (Ex: 1 / `Inf` is 0)  
* `Nan` - represents an undefined value ("not a number") (Ex: 0/0 is `NaN`).  
  + Can also be thought of as a missing value  
* **Attributes -** Some objects in R come with attributes. These attributes can be set or modified with the expression `attributes()`. They are:  
  + names, dimnames (dimension names)
  + dimensions (e.g. matrices, arrays) - number of rows & cols, or more depending on dimensions of array
  + class - the data type of the object
  + length - number of elements
  + other user-defined attributes/metadata can be added  
* **Coercion -** occurs so that every element of a vector is of the same class (Covered further in Vector section)  



## Different atomic data types

* R has five basic, or "atomic", classes of objects:  
  + character  
    - In `R` there is no `string` data type. It is also considered part of the `character` data type
  + numeric (real numbers)  
    - R thinks as numbers as these by default  
  + integer  
    - Must be explicity declared with the L suffix; `x <- 1` assigns a numeric object, but `x <- 1L` explicitly assigns an integer  
  + complex   
  + logical (True/False)  

* A vector can only contain objects of the same class  
  + an empty vector can be created with `vector()`  
* However, a **list** is represented as a vector but can contain objects of different classes (as such we usually use these)  

## Vectors, Lists, and Matrices   

* The `c()` function (can be thought to stand for "concatenate")  
  + Can be used to create vectors of objects  
```{r}
x <- c(0.5, 0.6) ## numeric
x <- c(TRUE, FALSE) ## logical
x <- c(T, F) ## logical
x <- c("a", "b", "c") ## character
x <- c(1+0i, 2+4i) ## complex
```
* The `vector()` function  
  + Can also be used to create, you guessed it, vectors  
```{r}
x <- vector() ## Creates an empty vector
x ## Prints as code that evaluates as FALSE

x <- vector(mode = "numeric", length = 10) ## Creates a vector with length "10" of 
## numeric data type,default value is 0
x

x <- vector("numeric", 5) ##The parameter names are not required, but can easily clarify code
x
```
  + When different objects are mixed in a vector, **coercion** occurs so all objects are of the same class.  
    - R will implicitly create the "Least Common Denominator" of the mixed classes
```{r}
y <- c(1.7, "a") ## character
y

y <- c(TRUE, 2) ## numeric
y

y <- c("a", TRUE) ## character
y
y[2] ## "TRUE" is a string stored as a "character" data type
y[3] ## The third element does not exist
```
    
  + Objects can be **explicitly coerced** from onne class to another using the `as.*` functions, if available.  
    - Nonsensical coercion reasults in `NA`s
```{r}
x <- 0:6
class(x)
as.numeric(x)
as.logical(x)
as.character(x)
as.complex(x)
x
y <- as.character(x)
y

x <- c("a", "b", "c")
as.numeric(x) ##Nonsensical coercion will also show a warning
as.logical(x)
as.complex(x)
```
    
* Lists (Important data type in R that you should get to know well)
  + Lists are a type of vector that can contain elements of different classes.
  + Doesn't print like a vector because every element is different
    - prints index of element with double brackets bordering it: `[[1]]`
```{r}
x <- list(1, "a", TRUE, 1 + 4i, 16 +18i)
x
```
  
* **Matrices -** a type of vector with a *dimension* attribute.  
  + The *dimension* attribute is itself an integer vector of length 2 (numRows, numCols)
  + Constructed *column-wise*, so entries can be thought of starting in the "upper left" corner, then running down the columns  
  + Matrices can also be created by adding a *dimension* attribute to an existing vector
```{r}
m <- matrix(nrow = 2, ncol = 3)
m
dim(m)##reports num of rows then cols
attributes(m) ## dim is an attribute of the vector
m <- matrix(1:6, 2, 3) ## Demonstrating column-wise filling of matrix
m

m <- 1:10 ## m is now just a vector
m

dim(m) <- c(2,5) ## adding the dimension attribute
m
```

  + Creating a matrix with **cbind** and **rbind**
    - cbind fills the columns with the elements of the vectors that are passed as the respective parameters
    - likewise, rbind fills the rows with the elements of the respective parameters
```{r}
x <- 1:3
y <- 10:12
cbind(x,y)
rbind(x,y)
```
    
## Other data types
* Factors  
  + Used to represent categorical data  
  + can be unordered or ordered
  + Kinda like enumerated data, where it's an integer at heart, and each integer has a *label*
  + Using factors with labels is *better* than using integers because factors are self-describing
    - consider "Male" and "Female" as opposed to just the values 1 and 2
  + Prints differently than a character value, does not include quotations and displays *Levels*
```{r}
x <- factor(c("yes", "yes", "no", "yes", "no"))
x
table(x) ## displays a frequency table of the factors
unclass(x) ## strips out the class and displays the underlying integer vector
```
  + The order of the levels can be set with the `levels` argument to `factor()`
    - This can be important in linear modelling because the first level is sued as the baseline level.
    - default levels are based alphabetically 
```{r}
x <- factor(
        c("yes", "yes", "no", "yes", "no"),
        levels = c("yes", "no")
        )
x
```
    
  
  
* Missing Values (`NA` or `NaN`)
  + `NaN` is for undefined mathematical operations
  + `is.na()` and `is.nan()` are logical tests for the respective missing values
  + `NA` values have a class also, so there are integer `NA`, character `NA`, etc.
  + a `NaN` is also a `NA`, however the converse is not true
```{r}
x <- c(1, 2, NA, 10, 3)
is.na(x)
is.nan(x)
x <- c(1, 2, NaN, NA, 4)
is.na(x)
is.nan(x)
```
  
  
* Data Frames
  + Used to store tabular data
  + Special type of list where every element has to have the same length
  + Each element is like a column and the length of each element is the number of rows
  + like lists, Data Frames can store different classes in each column
  + Attribute: `row.names`
    - Useful for annotating data
    - However, often the row names are not interesting and we use "1, 2, 3..."
  + Usually created by calling `read.table()` or `read.csv()`
  + Can be converted to a matrix with `data.matrix()`
    - Forces each object to be coerced
```{r}
x <- data.frame(foo = 1:4, bar = c(T, T, F, F))## cols are named here
x
nrow(x)
ncol(x)
row.names(x)

```

  
* Names Attribute, useful for writing readable code and self-describing objects
  + Any R object can have names
```{r}
x <- 1:3
names(x)## by default there are no names
names(x) <- c("foo", "bar", "norf")
x
names(x)

##Lists can also have names
x <- list(a=1, b=2, c=3) ## here, names are assigned as list is established
x

## Matrices can also have names, called dimnames
m <- matrix(1:4, nrow = 2, ncol = 2)
m
dimnames(m) <- list(c("a", "b"), c("c", "d")) ##First vector is rownames, second is colnames
m
```
  
## Reading Data  

### Tabular Data
* Functions for **reading** data into R  
  + `read.table`,`read.csv` - for reading tabular data 
    - most common  
    - reads in data that's organized into rows and cols
    - returns a data frame
  + `readLines`, for reading lines of a text file  
  + `source`, for reading in R code files (inverse of `dump`)  
  + `dget`, for reading in R code files (inverse of `dput`)  
  + `load`, for reading in saved workspaces  
  + `unserialize`, for reading single R objects in binary form  
* Functions for **writing** data from R to files
  + `write.table`  
  + `writeLines`  
  + `dump`  
  + `dput`  
  + `save`  
  + `serialize`  
* Arguments of `read.table` function
  + `file` - the name of a file or connection  
  + `header` - logical that indicates if the file has a header line  
  + `sep` - a string that indicates how the columns are separated (tokens)  
  + `colClasses` - a character vector that indicates the class (Data type) of each column  
  + `nrows`  
  + `comment.char` - character string that indicates the comment character (default is '#')  
  + `skip` - number of lines to skip from the beginning  
  + `stringsAsFactors` - (default = TRUE) should character variables be coded as factors?  
* Implicit actions `R` takes
```{r}
data <- read.table("foo.txt") 
## Header must not have a label for the row labels for R to implicitly determine them
data

```
  + Skips lines that begin with a #
  + figures out how many rows there are (and how much memory needs to be allocated)
  + figure what type of variable is in each column of the table.
    - Telling R all these things directly will make it run faster and more efficiently
* `read.csv` is identical to `read.table` except that the default separator is a comma
  - `.csv` files are common output from excel or other spreadsheet programs.

### Large Datasets  
* Doing the following things will make your life easier and prevent R from "choking"
  + [Read the help page for read.table, which contains many hints](https://www.rdocumentation.org/packages/utils/versions/3.6.2/topics/read.table)  
  + Make a rough calculation of the memory required to store your dataset. 
    - Say for example, you have a data frame with 1,500,000 rows and 120 columns (not *that* big), all of which are numeric data. To roughly claculate how much memory is requrired..  
    - 1,500,000 * 120 * 8 bytes/numeric = 1440000000 bytes  
    - 1440000000 bytes / $2^{20}$ bytes/MB = 1,373.29 MB  
    - 1,373.29 MB = 1.37 GB  
    - Rule of thumb is that you'll need twice the amount of RAM to be able to read in the dataset  
  + If the dataset is larger than the amount of RAM on your computer you can probably stop right here.
    - Type `free -k` in terminal to return amount of RAM in kilobytes (`-b` for bytes, `-m` for megabytes and `-g` for gigabytes)
  + Set `comment.char = ""` if there are no commented lines in your file.
  + Use the `colClasses` argument.
    - Specifying this option instead of using the default can make `read.table` run *MUCH* faster.
    - To use this option you have to know the class of each column in your data frame.
    - If all of the columns are of the same data type, for example "numeric", then you can just set `colClasses = "numeric"`
    - A quick and dirty way to figure out the clases of each column is to take a small sample and determine it from that.
```{r}
initial <- read.table("datatable.txt", nrows = 100)
classes <- sapply(initial, class)
classes ##Coded file wrong, I'm not gonna fix it now, Boolean should have said "TRUE" or "FALSE"
tabAll <- read.table("datatable.txt", 
                     colClasses = classes)
```
  + Set `nrows` 
    - This doesn't make R run faster but it helps with memory usage. 
    - A mild overestimate is okay.
    - You can type `wc <filename>` in terminal to return the number of: lines, strings, characters; "lines" are the `nrows`.  

* When using R with larger datasets it's useful to know a few things about your system  
  + How much memory is available  
    - Type `free -k` into terminal  
  + What other applications are in use  
    - Type `ps aux` in terminal  
  + Are there other users logged into the same system  
    - Type `w` in terminal (Note: `last` will report a history)  
  + What OS are you using  
    - Type `lsb_release -a` into terminal  
  + Is the OS 32 or 64 bit  
    - Type `lscpu`, listed under first two returns 
    - On a 64 bit system you'll generallly be able to access more memory

### Textual Formats  
* Contains the metadata, such as classes of columns, making transfering data more efficent as the metadata doesn't need to be determined again.  
* Known as `dumping` and `dputing`.
* Edit-able, which in the case of corruption allows for a potential recovery.
* Textual formats can work much better with version control programs.
* Adhere to the "Unix philosophy", which is to store data as text
* *Downside:* The format is not very space-efficient and as such ussually requires compression  
* `dput` will deparse an R object, and `dget` can read the data back in from a file
```{r}
y <- data.frame(a=1, b="a")
dput(y) ## If file is not specified the output is displayed in the console
dput(y, file = "y.R")
new.y <- dget("y.R")##dget retrieves the object from a file
new.y
```

* Multiple objects can be deparsed using the `dump` function, then read back in with `source`  
  + The parameter for `dump` is a character vector that contains characters for the names of the variables one wishes to dump
```{r}
x <- "foo"
y <- data.frame(a=1, b="a")
dump(c("x", "y"))
dump(c("x", "y"), file = "data.R")
rm(x, y) ## removes the variables
source("data.R") ## reconstructs y and x objects
y
x
```

### Connections (Interfaces to the outside world)
* Connections can be made to files or to other, more "exotic" things.  
  + `file` - opens a connection to a file  
  + `gzfile` - opens a connection to a file compressed with *gzip*.  
  + `bzfile` - opens a connection to a file compressed with *bzip2*.  
  + `url` - opens a connection to a webpage (in HTML format).  
* Arguments  
  + `description` is the name of the file  
  + `open` indicates how the file is opened
    - **"r" -** read only  
    - **"w" -** writing (and initializing a new file)  
    - **"a" -** appending  
    - **"rb", "wb", "ab" -** reading, writing, or appending in binary mode (Windows)  
    - There are other options but they aren't uber important  
* Connections are powerful tools that allow you to navigate files or other external objects in a more "sophisticated" way. 
  + However, one does not need to deal with the connection interface in many case    
```{r}
con <- file("foo.txt", "r")
data <- read.csv(con)
close(con)
```
  + ^This is the same as..  
```{r}
data <- read.csv("foo.txt")
```
  + As such, the connection was not nessacary for this case
* Reading lines of a text file with `con` from a *gzip* file  
```{r}
con <- gzfile("words.gz")
x <- readLines(con, 10) ##reads in first 10 lines
x
```
  + `writeLines` takes a character vector and writes each element one line at a time to a text file  
* `readLines` can be used for reading in lines of webpages.  
```{r}
## This might take time
con <- url("http://www.jhsph.edu", "r") ##John Hopkin's School of Public Health
x <- readLines(con)
head(x) ##Displays the header
```

## Subsetting R objects using the "[", "[[", and "$" operators and logical vectors  

### Basics
* Operators to extract subsets of R objects
  + `[` always returns an object of the same class as the original
    - subsetting a vector will return a vector, a list will return a list, etc.
    - Can be used to select more than one element (there is one exception)
  + `[[` is used to extract elements of a *list* or *data frame*
    - Can only be used to extract a single element
    - The class of the returned object will not necessarily be a list or data frame
  + `$` is used to extract elements of a *list* or *data frame* by name
    - Similar to `[[` as it may not be of the same class
* Numerical Index for subsetting:
```{r}
x <- c("a", "b", "c", "c", "d", "a")
x[1] ## Returns first element
x[2] ## Returns second element
x[1:4] ## Returns first to fourth elements
```
* Logical Index for subsetting:
```{r}
x <- c("a", "b", "c", "c", "d", "a")
x[x > "a"]## returns all elements that are greater than "a"
u <- x > "a" ## u is a logical vector that indicates which elements of x are greater than "a"
u
x[u] ## subsets all elements of x such that u reports that index as TRUE; elements that are > "a"
```


### Lists
* Lists can be subsetted with the `[[` or `$` operators
```{r}
x <- list(foo = 1:4, bar = 0.6)
x[1]##Extracts the first element as a list, since the orginal set was a list class
x[[1]]##Extracts the first element as a sequence, not a list
x$bar ##returns the element that is associated with the name "bar"
x[["bar"]]##same as x$bar
x["bar"]##returns a list with the element "bar" in it
```
  + subsetting with the name is helpful when the index isn't known
* To extract multiple elements of a list, one must use the single bracket operator `[`
```{r}
x <- list(foo = 1:4, bar = 0.6, baz = "hello")
x[c(1, 3)]##extracts the first and third element of the list
```
* The `[[` operator can be used with *computed* indices, whereas `$` can only be used with literal names.
```{r}
x <- list(foo = 1:4, bar = 0.6, baz = "hello")
name <- "foo"
x[[name]] ## computed index for 'foo'
x$name ## element 'name' doesn't exist!
x$foo ## element 'foo' does exist
```
* The `[[` can also take an integer sequence instead of a single number
```{r}
x <- list(a = list(10, 12, 14), b = c(3.14, 2.81))
x[[c(1,3)]] ##extracts first element, then the third element of said first element
x[[1]][[3]] ##equivelent
x[[c(2,1)]]##extracts first element of the second element of x
```


### Matrices


### Partial Matching


## Removing missing (NA) values from a vector



## Basic Arithmetic operations











# Control structures, functions, scoping rules, dates and times


# Loop functions, debugging tools


# Simulation, code profiling
